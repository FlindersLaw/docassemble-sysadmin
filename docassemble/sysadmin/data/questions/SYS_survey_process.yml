# Processes the submitted survey preferences and allocates students
# to seminars.
#
# Logic flow goes something like this:
# - read all student data into a DAList
# - read all the project data into DAList
# - project data structure must record seminar the project is allocated to
#   and number of students allocated to it
# - 
# for each student in the list
# - choose a student at random
# - allocate preferences based on following:
#   - students can't be allocated to a project already  in another seminar
#   - students can't be allocated to a project that is full
#   - try to allocate first, second, third prefs
#   - if that fails (or if there are no prefs)
#     - construct a list of projects allocated to that seminar plus
#       projects not allocated to any seminar
#     - only add projects with available student spots to the list
#     - projects should not be over-allocated to a seminar.  We have
#       19 projects so no seminar should have more than 10 (don't
#       hard-code these numbers though - cater for different numbers
#       of projects and different numbers of seminars)
#     - allocate a student to a random project 
#     - allocate that project to that seminar
#
# Display the output as a table ie:
# Seminar | Project ID | Project Description | Members
#
# Off we go!!
---
include:
  - SYS_survey_constants.yml
---
imports:
  - random
---
# Initialise random number generator
mandatory: True
code: |
  random.seed = (os.urandom(1024))
---
# First attempt at main block
# Easier if I make this mandatory
mandatory: True
code: |
  for a_student in shuffled_students:
    # DA may run this loop more than one time.  Skip over
    # students already allocated
    if a_student['allocated']:
      continue
  
    # If the student isn't allocated to a seminar then we skip.  Students
    # allocated to a seminar have a 'seminar' value that begins with 'Seminar'
    if a_student['seminar'][:7] != MJFconstants.seminar_prefix:
      continue

    # Get the student's pref data
    # del so it's always reset
    del a_prefs_entry
    a_prefs_entry

    # Run through each pref.  For each pref
    # - check the project's seminar matches the student's seminar
    # - if the project seminaris empty, allocate it to the student's seminar
    # - allocate the student if seminar matches and there are 
    #   vacancies
    # only do this if we have a record.  No record => no prefs
    if a_prefs_entry is not None:
      for a_pref in a_prefs_entry['prefs']:
        if projects_dictionary[a_pref]['seminar'] == a_student['seminar'] or
            projects_dictionary[a_pref]['seminar'] is None:

          # Student can be added, but only if the max group size hasn't been
          # exceeded yet.
          if len(projects_dictionary[a_pref]['students']) < MJFconstants.max_group_size:
            # Now we're good to go.  The project can be (re-)assigned to this 
            # seminar and the student can be added
            projects_dictionary[a_pref]['seminar'] = a_student['seminar']
            projects_dictionary[a_pref]['students'].append(a_student['FAN'])
            a_student['allocated'] = True

    # At this point if the student hasn't been added to a project it means 
    # that either their preferences were exhausted or they didn't record
    # any preferences.  So, we add them to a random project.
    
    if a_student['allocated']:
      # If they're allocated we just move on.
      continue
    
    for a_project in shuffled_projects:
      project_id = a_project['Project Identifier']

      if ( projects_dictionary[project_id]['seminar'] == a_student['seminar'] or 
            projects_dictionary[project_id]['seminar'] is None 
          ) and (
            len(projects_dictionary[project_id]['students']) < MJFconstants.max_group_size )
          ):
        # We have a project in the right seminar with vacancies so allocate
        # the student here
        projects_dictionary[project_id]['seminar'] = a_student['seminar']
        projects_dictionary[project_id]['students'].append(a_student['FAN'])
        a_student['allocated'] = True
        # Get out of the loop once we're allocated
        continue
---
# Displays the table
mandatory: True
question: Project Allocation
subquestion:
  TODO: Something descriptive to go here at some stage

  ${ project_allocation_table }
---
table: project_allocation_table
rows: current_projects_data
columns:
  - Project ID:
      row_item['project_id']
  - Project Description:
      row_item['project_description']
  - Allocated Seminar:
      projects_dictionary[row_item['Project Identifier']]['seminar']
  - Members:
      projects_dictionary[row_item['Project Identifier']]['students']
---
# Get the current projects
code: |
  current_projects_data = llaw3301_data.get(MJFconstants.data_type_project)
---
# Get the current student data
code: |
  current_students_data = llaw3301_data.get(MJFconstants.data_type_student)
---
# Convert projects data into a dictionary - easier to access
# Each dictionary has the following in a sub-dictionary
# - the project description
# - the seminar to which the project is allocated (initialised to None)
# - a list of allocated students (initialised to [])
code: |
  projects_dictionary = {}
  for MJFitem in current_projects_data:
    item_key = MJFitem['Project Identifier']
    item_value = item_key + ': ' + MJFitem['Description'] + ' (' + MJFitem['Organisation'] + ')'
    projects_dictionary[item_key] = {
        'description' : item_value,
        'seminar'     : '',
        'students'    : []
      }
--
# Get a student record from the DAstore
code:
  a_prefs_entry = llaw3301_data.get(MJFconstants.survey_input_record + a_student['FAN'])
---
#Shuffles the list of students
code: |
  shuffled_students = random.shuffle(current_students_data, len(current_students_data))
  # Initialise all students to be unallocated
  for a_shuffled_student in shuffled_students:
    a_shuffled_student['allocated'] = False
---
# Shuffles the list of projects - for random allocation
code: |
  shuffled_projects = random.shuffle(current_projects_data, len(current_projects_data))
---